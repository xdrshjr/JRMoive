# AI短剧自动化生成系统开发教程（第2部分）
## 核心代码实现：剧本解析与图片生成

---

## 目录

1. [模块1：剧本解析与分镜设计](#模块1剧本解析与分镜设计)
   - 1.1 [数据模型设计](#11-数据模型设计)
   - 1.2 [剧本解析Agent实现](#12-剧本解析agent实现)
   - 1.3 [分镜设计策略](#13-分镜设计策略)
2. [模块2：Nano Banana Pro图片生成Agent](#模块2nano-banana-pro图片生成agent)
   - 2.1 [API服务封装](#21-api服务封装)
   - 2.2 [图片生成Agent实现](#22-图片生成agent实现)
   - 2.3 [批量处理与并发控制](#23-批量处理与并发控制)

---

## 模块1：剧本解析与分镜设计

### 1.1 数据模型设计

#### 1.1.1 剧本数据模型

创建`models/script_models.py`：

```python
from typing import List, Optional, Dict, Any
from pydantic import BaseModel, Field, validator
from enum import Enum
from datetime import timedelta

class ShotType(Enum):
    """镜头类型"""
    CLOSE_UP = "close_up"              # 特写
    MEDIUM_SHOT = "medium_shot"        # 中景
    LONG_SHOT = "long_shot"            # 远景
    EXTREME_CLOSE_UP = "extreme_close_up"  # 大特写
    FULL_SHOT = "full_shot"            # 全景
    OVER_SHOULDER = "over_shoulder"    # 过肩镜头

class CameraMovement(Enum):
    """摄像机运动"""
    STATIC = "static"                  # 静止
    PAN = "pan"                        # 摇镜
    TILT = "tilt"                      # 俯仰
    ZOOM = "zoom"                      # 推拉
    DOLLY = "dolly"                    # 移动
    TRACKING = "tracking"              # 跟踪

class Character(BaseModel):
    """角色模型"""
    name: str = Field(..., description="角色名称")
    description: str = Field(..., description="角色描述（外貌、性格等）")
    age: Optional[int] = Field(None, description="年龄")
    gender: Optional[str] = Field(None, description="性别")
    appearance: Optional[str] = Field(None, description="外貌特征")

    class Config:
        json_schema_extra = {
            "example": {
                "name": "小明",
                "description": "25岁的年轻程序员，戴眼镜，清秀",
                "age": 25,
                "gender": "male",
                "appearance": "黑框眼镜，短发，白色T恤"
            }
        }

class Dialogue(BaseModel):
    """对话模型"""
    character: str = Field(..., description="说话的角色")
    content: str = Field(..., description="对话内容")
    emotion: Optional[str] = Field(None, description="情绪（高兴、悲伤、愤怒等）")
    voice_style: Optional[str] = Field(None, description="语音风格（用于TTS）")

    class Config:
        json_schema_extra = {
            "example": {
                "character": "小明",
                "content": "今天的代码终于跑通了！",
                "emotion": "excited",
                "voice_style": "energetic"
            }
        }

class Scene(BaseModel):
    """场景模型"""
    scene_id: str = Field(..., description="场景唯一标识符")
    location: str = Field(..., description="地点（如：咖啡馆、办公室）")
    time: str = Field(..., description="时间（如：清晨、黄昏）")
    weather: Optional[str] = Field(None, description="天气（晴天、雨天等）")
    atmosphere: Optional[str] = Field(None, description="氛围（温馨、紧张等）")
    description: str = Field(..., description="场景详细描述")

    # 分镜参数
    shot_type: ShotType = Field(default=ShotType.MEDIUM_SHOT, description="镜头类型")
    camera_movement: CameraMovement = Field(default=CameraMovement.STATIC, description="摄像机运动")
    duration: float = Field(default=3.0, ge=1.0, le=10.0, description="时长（秒）")

    # 内容
    characters: List[str] = Field(default_factory=list, description="出现的角色")
    dialogues: List[Dialogue] = Field(default_factory=list, description="对话列表")
    action: Optional[str] = Field(None, description="动作描述")

    # 视觉风格
    visual_style: Optional[str] = Field(None, description="视觉风格（cinematic, anime等）")
    color_tone: Optional[str] = Field(None, description="色调（warm, cool, vibrant等）")

    @validator('duration')
    def validate_duration(cls, v):
        """验证时长合法性"""
        if v < 1.0 or v > 10.0:
            raise ValueError("Scene duration must be between 1 and 10 seconds")
        return v

    def to_image_prompt(self) -> str:
        """
        将场景转换为图片生成提示词

        Returns:
            适合AI图片生成的提示词
        """
        prompt_parts = []

        # 基础场景描述
        prompt_parts.append(f"{self.location}, {self.time}")

        # 天气和氛围
        if self.weather:
            prompt_parts.append(f"{self.weather} weather")
        if self.atmosphere:
            prompt_parts.append(f"{self.atmosphere} atmosphere")

        # 角色和动作
        if self.characters:
            char_desc = ", ".join(self.characters)
            prompt_parts.append(f"characters: {char_desc}")
        if self.action:
            prompt_parts.append(self.action)

        # 详细描述
        prompt_parts.append(self.description)

        # 镜头类型
        prompt_parts.append(f"{self.shot_type.value} shot")

        # 视觉风格
        if self.visual_style:
            prompt_parts.append(f"{self.visual_style} style")
        if self.color_tone:
            prompt_parts.append(f"{self.color_tone} color tone")

        return ", ".join(prompt_parts)

    class Config:
        use_enum_values = True
        json_schema_extra = {
            "example": {
                "scene_id": "scene_001",
                "location": "cozy coffee shop",
                "time": "morning",
                "weather": "sunny",
                "atmosphere": "warm and peaceful",
                "description": "Sunlight streams through large windows",
                "shot_type": "medium_shot",
                "camera_movement": "static",
                "duration": 3.5,
                "characters": ["Xiao Ming"],
                "action": "sitting by the window, holding a coffee cup"
            }
        }

class Script(BaseModel):
    """完整剧本模型"""
    title: str = Field(..., description="剧本标题")
    author: Optional[str] = Field(None, description="作者")
    description: Optional[str] = Field(None, description="剧本简介")
    characters: List[Character] = Field(default_factory=list, description="角色列表")
    scenes: List[Scene] = Field(..., description="场景列表")
    metadata: Dict[str, Any] = Field(default_factory=dict, description="元数据")

    @property
    def total_duration(self) -> float:
        """计算总时长（秒）"""
        return sum(scene.duration for scene in self.scenes)

    @property
    def total_scenes(self) -> int:
        """场景总数"""
        return len(self.scenes)

    def validate_script(self) -> List[str]:
        """
        验证剧本完整性

        Returns:
            错误信息列表（空列表表示无错误）
        """
        errors = []

        if not self.scenes:
            errors.append("Script must have at least one scene")

        if self.total_duration > 600:  # 限制最长10分钟
            errors.append(f"Total duration {self.total_duration}s exceeds 600s limit")

        # 验证角色一致性
        declared_chars = {char.name for char in self.characters}
        used_chars = set()
        for scene in self.scenes:
            used_chars.update(scene.characters)
            for dialogue in scene.dialogues:
                used_chars.add(dialogue.character)

        undeclared = used_chars - declared_chars
        if undeclared:
            errors.append(f"Undeclared characters: {undeclared}")

        return errors

    class Config:
        json_schema_extra = {
            "example": {
                "title": "程序员的一天",
                "author": "AI编剧",
                "description": "讲述一个程序员日常工作的温馨故事",
                "characters": [
                    {
                        "name": "小明",
                        "description": "年轻的Python开发者",
                        "age": 25,
                        "gender": "male"
                    }
                ],
                "scenes": []
            }
        }
```

---

### 1.2 剧本解析Agent实现

#### 1.2.1 文本剧本格式定义

支持的剧本文本格式示例：

```text
# 程序员的一天

## 角色
- 小明: 25岁的Python开发者，戴黑框眼镜

## 场景1：清晨的咖啡馆
地点: 咖啡馆
时间: 清晨
天气: 晴朗
氛围: 温馨安静
时长: 3.5秒
镜头: 中景
描述: 阳光透过大窗户洒进咖啡馆，小明坐在窗边的位置

小明（微笑）：今天又是充满希望的一天！

## 场景2：办公室
地点: 现代化办公室
时间: 上午
镜头: 特写
时长: 4.0秒
描述: 小明专注地盯着屏幕，手指在键盘上飞舞

小明（专注）：这个bug一定要在上线前修复...
```

#### 1.2.2 剧本解析器实现

创建`agents/script_parser_agent.py`：

```python
import re
from typing import List, Dict, Any, Optional
from models.script_models import (
    Script, Scene, Character, Dialogue,
    ShotType, CameraMovement
)
from agents.base_agent import BaseAgent
import logging

class ScriptParserAgent(BaseAgent):
    """剧本解析Agent - 将文本剧本转换为结构化数据"""

    def __init__(self, agent_id: str = "script_parser", config: Dict[str, Any] = None):
        super().__init__(agent_id, config or {})
        self.logger = logging.getLogger(__name__)

    async def execute(self, input_data: str) -> Script:
        """
        执行剧本解析

        Args:
            input_data: 原始剧本文本

        Returns:
            结构化的Script对象

        Raises:
            ValueError: 剧本格式错误
        """
        if not await self.validate_input(input_data):
            raise ValueError("Invalid script format")

        try:
            # 解析剧本元数据
            title = self._extract_title(input_data)
            author = self._extract_author(input_data)
            description = self._extract_description(input_data)

            # 解析角色
            characters = self._parse_characters(input_data)

            # 解析场景
            scenes = self._parse_scenes(input_data)

            # 构建Script对象
            script = Script(
                title=title,
                author=author,
                description=description,
                characters=characters,
                scenes=scenes
            )

            # 验证剧本
            errors = script.validate_script()
            if errors:
                self.logger.warning(f"Script validation warnings: {errors}")

            await self.on_complete(script)
            return script

        except Exception as e:
            await self.on_error(e)
            raise

    async def validate_input(self, input_data: str) -> bool:
        """验证输入数据"""
        if not input_data or not isinstance(input_data, str):
            return False

        # 至少包含一个场景标记
        if not re.search(r'##\s*场景\d+', input_data):
            return False

        return True

    def _extract_title(self, text: str) -> str:
        """提取剧本标题"""
        match = re.search(r'^#\s+(.+)$', text, re.MULTILINE)
        return match.group(1).strip() if match else "未命名剧本"

    def _extract_author(self, text: str) -> Optional[str]:
        """提取作者信息"""
        match = re.search(r'作者[:：]\s*(.+)$', text, re.MULTILINE)
        return match.group(1).strip() if match else None

    def _extract_description(self, text: str) -> Optional[str]:
        """提取剧本简介"""
        match = re.search(r'简介[:：]\s*(.+)$', text, re.MULTILINE)
        return match.group(1).strip() if match else None

    def _parse_characters(self, text: str) -> List[Character]:
        """
        解析角色列表

        格式: - 角色名: 描述
        """
        characters = []
        char_section = re.search(
            r'##\s*角色\s*\n(.*?)(?=##|\Z)',
            text,
            re.DOTALL
        )

        if not char_section:
            return characters

        char_lines = char_section.group(1).strip().split('\n')
        for line in char_lines:
            line = line.strip()
            if line.startswith('-'):
                # 格式: - 小明: 25岁的Python开发者，戴黑框眼镜
                match = re.match(r'-\s*([^:：]+)[:：]\s*(.+)', line)
                if match:
                    name = match.group(1).strip()
                    description = match.group(2).strip()

                    # 尝试提取年龄和性别
                    age = None
                    gender = None

                    age_match = re.search(r'(\d+)岁', description)
                    if age_match:
                        age = int(age_match.group(1))

                    if '男' in description or 'male' in description.lower():
                        gender = 'male'
                    elif '女' in description or 'female' in description.lower():
                        gender = 'female'

                    characters.append(Character(
                        name=name,
                        description=description,
                        age=age,
                        gender=gender
                    ))

        return characters

    def _parse_scenes(self, text: str) -> List[Scene]:
        """
        解析场景列表

        场景格式:
        ## 场景N：场景名称
        地点: XXX
        时间: XXX
        ...
        """
        scenes = []

        # 分割场景
        scene_pattern = r'##\s*场景(\d+)[：:]\s*(.+?)\n(.*?)(?=##\s*场景\d+|$)'
        matches = re.finditer(scene_pattern, text, re.DOTALL)

        for match in matches:
            scene_num = match.group(1)
            scene_name = match.group(2).strip()
            scene_content = match.group(3).strip()

            # 解析场景属性
            scene_data = self._parse_scene_content(
                scene_id=f"scene_{scene_num.zfill(3)}",
                scene_name=scene_name,
                content=scene_content
            )

            if scene_data:
                scenes.append(scene_data)

        return scenes

    def _parse_scene_content(self, scene_id: str, scene_name: str,
                            content: str) -> Optional[Scene]:
        """解析单个场景的内容"""
        try:
            # 提取场景属性
            location = self._extract_field(content, r'地点[:：]\s*(.+)')
            time = self._extract_field(content, r'时间[:：]\s*(.+)')
            weather = self._extract_field(content, r'天气[:：]\s*(.+)')
            atmosphere = self._extract_field(content, r'氛围[:：]\s*(.+)')
            description = self._extract_field(content, r'描述[:：]\s*(.+)')

            # 提取镜头参数
            duration_str = self._extract_field(content, r'时长[:：]\s*([\d.]+)')
            duration = float(duration_str) if duration_str else 3.0

            shot_type_str = self._extract_field(content, r'镜头[:：]\s*(.+)')
            shot_type = self._parse_shot_type(shot_type_str)

            camera_movement_str = self._extract_field(content, r'运镜[:：]\s*(.+)')
            camera_movement = self._parse_camera_movement(camera_movement_str)

            visual_style = self._extract_field(content, r'风格[:：]\s*(.+)')
            color_tone = self._extract_field(content, r'色调[:：]\s*(.+)')

            # 提取对话
            dialogues = self._extract_dialogues(content)

            # 提取动作
            action = self._extract_field(content, r'动作[:：]\s*(.+)')

            # 提取出现的角色
            characters = [d.character for d in dialogues]

            return Scene(
                scene_id=scene_id,
                location=location or scene_name,
                time=time or "白天",
                weather=weather,
                atmosphere=atmosphere,
                description=description or f"{location}, {time}",
                shot_type=shot_type,
                camera_movement=camera_movement,
                duration=duration,
                characters=characters,
                dialogues=dialogues,
                action=action,
                visual_style=visual_style,
                color_tone=color_tone
            )

        except Exception as e:
            self.logger.error(f"Failed to parse scene {scene_id}: {e}")
            return None

    def _extract_field(self, text: str, pattern: str) -> Optional[str]:
        """提取字段值"""
        match = re.search(pattern, text, re.MULTILINE)
        return match.group(1).strip() if match else None

    def _extract_dialogues(self, content: str) -> List[Dialogue]:
        """
        提取对话

        格式: 角色名（情绪）：对话内容
        """
        dialogues = []
        dialogue_pattern = r'([^（\(]+)(?:[（\(]([^）\)]+)[）\)])?[:：]\s*(.+)'

        for line in content.split('\n'):
            line = line.strip()
            match = re.match(dialogue_pattern, line)

            if match and not any(keyword in line for keyword in
                                ['地点', '时间', '天气', '氛围', '描述', '镜头', '时长']):
                character = match.group(1).strip()
                emotion = match.group(2).strip() if match.group(2) else None
                content_text = match.group(3).strip()

                dialogues.append(Dialogue(
                    character=character,
                    content=content_text,
                    emotion=emotion
                ))

        return dialogues

    def _parse_shot_type(self, shot_str: Optional[str]) -> ShotType:
        """解析镜头类型"""
        if not shot_str:
            return ShotType.MEDIUM_SHOT

        shot_mapping = {
            '特写': ShotType.CLOSE_UP,
            '大特写': ShotType.EXTREME_CLOSE_UP,
            '中景': ShotType.MEDIUM_SHOT,
            '远景': ShotType.LONG_SHOT,
            '全景': ShotType.FULL_SHOT,
            '过肩': ShotType.OVER_SHOULDER,
        }

        for key, value in shot_mapping.items():
            if key in shot_str:
                return value

        return ShotType.MEDIUM_SHOT

    def _parse_camera_movement(self, movement_str: Optional[str]) -> CameraMovement:
        """解析摄像机运动"""
        if not movement_str:
            return CameraMovement.STATIC

        movement_mapping = {
            '静止': CameraMovement.STATIC,
            '摇镜': CameraMovement.PAN,
            '俯仰': CameraMovement.TILT,
            '推拉': CameraMovement.ZOOM,
            '移动': CameraMovement.DOLLY,
            '跟踪': CameraMovement.TRACKING,
        }

        for key, value in movement_mapping.items():
            if key in movement_str:
                return value

        return CameraMovement.STATIC
```

#### 1.2.3 使用示例

```python
import asyncio
from agents.script_parser_agent import ScriptParserAgent

async def test_script_parser():
    """测试剧本解析"""

    script_text = """
# 程序员的一天

## 角色
- 小明: 25岁的Python开发者，戴黑框眼镜

## 场景1：清晨的咖啡馆
地点: 咖啡馆
时间: 清晨
天气: 晴朗
氛围: 温馨安静
时长: 3.5
镜头: 中景
描述: 阳光透过大窗户洒进咖啡馆，小明坐在窗边的位置

小明（微笑）：今天又是充满希望的一天！

## 场景2：办公室
地点: 现代化办公室
时间: 上午
镜头: 特写
时长: 4.0
描述: 小明专注地盯着屏幕，手指在键盘上飞舞

小明（专注）：这个bug一定要在上线前修复...
    """

    parser = ScriptParserAgent()
    script = await parser.execute(script_text)

    print(f"剧本标题: {script.title}")
    print(f"角色数量: {len(script.characters)}")
    print(f"场景数量: {len(script.scenes)}")
    print(f"总时长: {script.total_duration}秒")

    # 打印场景详情
    for scene in script.scenes:
        print(f"\n场景 {scene.scene_id}:")
        print(f"  地点: {scene.location}")
        print(f"  提示词: {scene.to_image_prompt()}")

if __name__ == "__main__":
    asyncio.run(test_script_parser())
```

---

### 1.3 分镜设计策略

#### 1.3.1 自动分镜优化

创建`utils/storyboard_optimizer.py`：

```python
from typing import List
from models.script_models import Scene, ShotType, CameraMovement

class StoryboardOptimizer:
    """分镜优化器 - 自动优化镜头设计"""

    @staticmethod
    def optimize_shot_sequence(scenes: List[Scene]) -> List[Scene]:
        """
        优化镜头序列，避免单调

        策略:
        1. 避免连续多个相同镜头类型
        2. 重要对话使用特写
        3. 场景转换时使用全景
        """
        if len(scenes) <= 1:
            return scenes

        optimized = scenes.copy()

        for i in range(1, len(optimized)):
            prev_scene = optimized[i - 1]
            curr_scene = optimized[i]

            # 避免连续相同镜头
            if prev_scene.shot_type == curr_scene.shot_type:
                curr_scene.shot_type = StoryboardOptimizer._get_alternate_shot(
                    curr_scene.shot_type
                )

            # 对话场景优化
            if curr_scene.dialogues:
                if len(curr_scene.dialogues) > 2:  # 多轮对话使用特写
                    curr_scene.shot_type = ShotType.CLOSE_UP

            # 场景转换使用全景
            if prev_scene.location != curr_scene.location:
                curr_scene.shot_type = ShotType.LONG_SHOT

        return optimized

    @staticmethod
    def _get_alternate_shot(current: ShotType) -> ShotType:
        """获取交替镜头类型"""
        alternates = {
            ShotType.CLOSE_UP: ShotType.MEDIUM_SHOT,
            ShotType.MEDIUM_SHOT: ShotType.CLOSE_UP,
            ShotType.LONG_SHOT: ShotType.MEDIUM_SHOT,
            ShotType.FULL_SHOT: ShotType.MEDIUM_SHOT,
        }
        return alternates.get(current, ShotType.MEDIUM_SHOT)

    @staticmethod
    def adjust_scene_durations(scenes: List[Scene],
                              target_total: float) -> List[Scene]:
        """
        调整场景时长以匹配目标总时长

        Args:
            scenes: 场景列表
            target_total: 目标总时长（秒）

        Returns:
            调整后的场景列表
        """
        current_total = sum(s.duration for s in scenes)
        scale_factor = target_total / current_total

        for scene in scenes:
            scene.duration = max(1.0, min(10.0, scene.duration * scale_factor))

        return scenes
```

---

## 模块2：Nano Banana Pro图片生成Agent

### 2.1 API服务封装

#### 2.1.1 Nano Banana API客户端

创建`services/nano_banana_service.py`：

```python
import httpx
import asyncio
from typing import Dict, Any, Optional, List
from config.settings import settings
from utils.retry import async_retry
import logging
from pathlib import Path
import base64

class NanoBananaService:
    """Nano Banana Pro API服务封装"""

    def __init__(self, api_key: Optional[str] = None,
                 base_url: Optional[str] = None):
        """
        初始化服务

        Args:
            api_key: API密钥（默认从settings读取）
            base_url: API基础URL（默认从settings读取）
        """
        self.api_key = api_key or settings.nano_banana_api_key
        self.base_url = base_url or settings.nano_banana_base_url
        self.logger = logging.getLogger(__name__)

        self.client = httpx.AsyncClient(
            base_url=self.base_url,
            headers={
                "Authorization": f"Bearer {self.api_key}",
                "Content-Type": "application/json"
            },
            timeout=60.0
        )

    async def close(self):
        """关闭客户端"""
        await self.client.aclose()

    @async_retry(max_attempts=3, backoff_factor=2.0)
    async def generate_image(
        self,
        prompt: str,
        negative_prompt: Optional[str] = None,
        width: int = 1024,
        height: int = 576,
        style: str = "cinematic",
        quality: str = "high",
        **kwargs
    ) -> Dict[str, Any]:
        """
        生成图片

        Args:
            prompt: 提示词
            negative_prompt: 负面提示词
            width: 图片宽度
            height: 图片高度
            style: 视觉风格
            quality: 质量等级
            **kwargs: 其他API参数

        Returns:
            API响应数据，包含image_url或image_data

        Raises:
            httpx.HTTPError: API请求失败
        """
        payload = {
            "prompt": prompt,
            "negative_prompt": negative_prompt or self._get_default_negative_prompt(),
            "width": width,
            "height": height,
            "style": style,
            "quality": quality,
            **kwargs
        }

        self.logger.info(f"Generating image with prompt: {prompt[:100]}...")

        try:
            response = await self.client.post(
                "/generate-image",
                json=payload
            )
            response.raise_for_status()

            result = response.json()
            self.logger.info(f"Image generated successfully: {result.get('id')}")

            return result

        except httpx.HTTPStatusError as e:
            self.logger.error(f"API request failed: {e.response.status_code}")
            self.logger.error(f"Response: {e.response.text}")
            raise

    async def download_image(self, image_url: str, save_path: Path) -> Path:
        """
        下载图片到本地

        Args:
            image_url: 图片URL
            save_path: 保存路径

        Returns:
            实际保存的文件路径
        """
        self.logger.info(f"Downloading image from {image_url}")

        try:
            response = await self.client.get(image_url)
            response.raise_for_status()

            save_path.parent.mkdir(parents=True, exist_ok=True)

            with open(save_path, 'wb') as f:
                f.write(response.content)

            self.logger.info(f"Image saved to {save_path}")
            return save_path

        except Exception as e:
            self.logger.error(f"Failed to download image: {e}")
            raise

    async def save_base64_image(self, base64_data: str, save_path: Path) -> Path:
        """
        保存Base64编码的图片

        Args:
            base64_data: Base64编码的图片数据
            save_path: 保存路径

        Returns:
            实际保存的文件路径
        """
        try:
            # 移除data URI前缀（如果存在）
            if ',' in base64_data:
                base64_data = base64_data.split(',', 1)[1]

            image_bytes = base64.b64decode(base64_data)

            save_path.parent.mkdir(parents=True, exist_ok=True)

            with open(save_path, 'wb') as f:
                f.write(image_bytes)

            self.logger.info(f"Base64 image saved to {save_path}")
            return save_path

        except Exception as e:
            self.logger.error(f"Failed to save base64 image: {e}")
            raise

    def _get_default_negative_prompt(self) -> str:
        """获取默认的负面提示词"""
        return (
            "low quality, blurry, distorted, watermark, "
            "text, logo, signature, worst quality, bad anatomy"
        )

    async def check_generation_status(self, task_id: str) -> Dict[str, Any]:
        """
        检查图片生成状态（如果API支持异步生成）

        Args:
            task_id: 任务ID

        Returns:
            任务状态信息
        """
        response = await self.client.get(f"/task/{task_id}")
        response.raise_for_status()
        return response.json()

    async def __aenter__(self):
        """异步上下文管理器入口"""
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """异步上下文管理器出口"""
        await self.close()
```

#### 2.1.2 重试机制实现

创建`utils/retry.py`：

```python
import asyncio
import functools
from typing import Callable, TypeVar, Optional, Tuple, Type
import logging

T = TypeVar('T')

def async_retry(
    max_attempts: int = 3,
    backoff_factor: float = 2.0,
    exceptions: Tuple[Type[Exception], ...] = (Exception,),
    logger: Optional[logging.Logger] = None
):
    """
    异步函数重试装饰器

    Args:
        max_attempts: 最大重试次数
        backoff_factor: 退避因子（指数退避）
        exceptions: 需要重试的异常类型
        logger: 日志记录器

    Example:
        @async_retry(max_attempts=3, backoff_factor=2.0)
        async def api_call():
            ...
    """
    if logger is None:
        logger = logging.getLogger(__name__)

    def decorator(func: Callable[..., T]) -> Callable[..., T]:
        @functools.wraps(func)
        async def wrapper(*args, **kwargs) -> T:
            last_exception = None

            for attempt in range(1, max_attempts + 1):
                try:
                    return await func(*args, **kwargs)

                except exceptions as e:
                    last_exception = e
                    if attempt < max_attempts:
                        wait_time = backoff_factor ** (attempt - 1)
                        logger.warning(
                            f"{func.__name__} failed (attempt {attempt}/{max_attempts}), "
                            f"retrying in {wait_time}s... Error: {e}"
                        )
                        await asyncio.sleep(wait_time)
                    else:
                        logger.error(
                            f"{func.__name__} failed after {max_attempts} attempts"
                        )

            raise last_exception

        return wrapper

    return decorator
```

---

### 2.2 图片生成Agent实现

创建`agents/image_generator_agent.py`：

```python
import asyncio
from typing import List, Dict, Any, Optional
from pathlib import Path
from agents.base_agent import BaseAgent
from services.nano_banana_service import NanoBananaService
from models.script_models import Scene
import logging
from datetime import datetime

class ImageGenerationAgent(BaseAgent):
    """图片生成Agent - 基于场景生成分镜图片"""

    def __init__(
        self,
        agent_id: str = "image_generator",
        config: Dict[str, Any] = None,
        output_dir: Optional[Path] = None
    ):
        super().__init__(agent_id, config or {})
        self.output_dir = output_dir or Path("./output/images")
        self.output_dir.mkdir(parents=True, exist_ok=True)

        self.service = NanoBananaService()
        self.logger = logging.getLogger(__name__)

    async def execute(self, scenes: List[Scene]) -> List[Dict[str, Any]]:
        """
        执行批量图片生成

        Args:
            scenes: 场景列表

        Returns:
            生成结果列表，每个元素包含scene_id和image_path
        """
        if not await self.validate_input(scenes):
            raise ValueError("Invalid scenes input")

        self.logger.info(f"Starting image generation for {len(scenes)} scenes")

        try:
            results = []

            for i, scene in enumerate(scenes):
                self.logger.info(f"Generating image {i+1}/{len(scenes)}: {scene.scene_id}")

                result = await self._generate_scene_image(scene)
                results.append(result)

                # 进度回调
                if hasattr(self, 'progress_callback') and self.progress_callback:
                    progress = (i + 1) / len(scenes) * 100
                    await self.progress_callback(progress, f"Generated {i+1}/{len(scenes)} images")

            await self.on_complete(results)
            return results

        except Exception as e:
            await self.on_error(e)
            raise

    async def validate_input(self, scenes: List[Scene]) -> bool:
        """验证输入场景列表"""
        if not scenes or not isinstance(scenes, list):
            return False

        if not all(isinstance(s, Scene) for s in scenes):
            return False

        return True

    async def _generate_scene_image(self, scene: Scene) -> Dict[str, Any]:
        """
        为单个场景生成图片

        Args:
            scene: 场景对象

        Returns:
            生成结果字典
        """
        # 构建提示词
        prompt = scene.to_image_prompt()

        # 生成图片
        api_result = await self.service.generate_image(
            prompt=prompt,
            width=self.config.get('image_width', 1024),
            height=self.config.get('image_height', 576),
            style=scene.visual_style or self.config.get('style', 'cinematic'),
            quality=self.config.get('quality', 'high')
        )

        # 保存图片
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"{scene.scene_id}_{timestamp}.png"
        save_path = self.output_dir / filename

        # 根据API返回格式下载或保存图片
        if 'image_url' in api_result:
            image_path = await self.service.download_image(
                api_result['image_url'],
                save_path
            )
        elif 'image_data' in api_result:
            image_path = await self.service.save_base64_image(
                api_result['image_data'],
                save_path
            )
        else:
            raise ValueError("API response missing image data")

        return {
            'scene_id': scene.scene_id,
            'image_path': str(image_path),
            'prompt': prompt,
            'api_response': api_result
        }

    async def close(self):
        """关闭资源"""
        await self.service.close()
```

---

### 2.3 批量处理与并发控制

#### 2.3.1 并发限制器

创建`utils/concurrency.py`：

```python
import asyncio
from typing import List, Callable, TypeVar, Any
import logging

T = TypeVar('T')

class ConcurrencyLimiter:
    """并发限制器 - 控制同时执行的异步任务数量"""

    def __init__(self, max_concurrent: int = 5):
        """
        初始化

        Args:
            max_concurrent: 最大并发数
        """
        self.semaphore = asyncio.Semaphore(max_concurrent)
        self.logger = logging.getLogger(__name__)

    async def run(self, func: Callable, *args, **kwargs) -> Any:
        """
        在并发限制下执行函数

        Args:
            func: 异步函数
            *args, **kwargs: 函数参数

        Returns:
            函数执行结果
        """
        async with self.semaphore:
            return await func(*args, **kwargs)

    async def run_batch(
        self,
        func: Callable[[T], Any],
        items: List[T],
        show_progress: bool = True
    ) -> List[Any]:
        """
        批量执行任务

        Args:
            func: 异步函数
            items: 输入项列表
            show_progress: 是否显示进度

        Returns:
            结果列表
        """
        tasks = [self.run(func, item) for item in items]

        if show_progress:
            return await self._run_with_progress(tasks)
        else:
            return await asyncio.gather(*tasks)

    async def _run_with_progress(self, tasks: List) -> List[Any]:
        """带进度显示的批量执行"""
        total = len(tasks)
        completed = 0
        results = []

        for coro in asyncio.as_completed(tasks):
            result = await coro
            results.append(result)
            completed += 1
            progress = completed / total * 100
            self.logger.info(f"Progress: {completed}/{total} ({progress:.1f}%)")

        return results
```

#### 2.3.2 批量图片生成增强版

扩展`ImageGenerationAgent`，添加并发控制：

```python
# 在 agents/image_generator_agent.py 中添加

from utils.concurrency import ConcurrencyLimiter
from config.settings import settings

class ImageGenerationAgent(BaseAgent):
    # ... 前面的代码保持不变 ...

    def __init__(self, agent_id: str = "image_generator",
                 config: Dict[str, Any] = None,
                 output_dir: Optional[Path] = None):
        super().__init__(agent_id, config or {})
        self.output_dir = output_dir or Path("./output/images")
        self.output_dir.mkdir(parents=True, exist_ok=True)

        self.service = NanoBananaService()
        self.logger = logging.getLogger(__name__)

        # 并发限制器
        max_concurrent = self.config.get(
            'max_concurrent',
            settings.max_concurrent_requests
        )
        self.limiter = ConcurrencyLimiter(max_concurrent)

    async def execute_concurrent(self, scenes: List[Scene]) -> List[Dict[str, Any]]:
        """
        并发执行图片生成（性能优化版）

        Args:
            scenes: 场景列表

        Returns:
            生成结果列表
        """
        if not await self.validate_input(scenes):
            raise ValueError("Invalid scenes input")

        self.logger.info(
            f"Starting concurrent image generation for {len(scenes)} scenes"
        )

        try:
            # 使用并发限制器批量执行
            results = await self.limiter.run_batch(
                self._generate_scene_image,
                scenes,
                show_progress=True
            )

            await self.on_complete(results)
            return results

        except Exception as e:
            await self.on_error(e)
            raise
```

#### 2.3.3 使用示例

```python
import asyncio
from agents.script_parser_agent import ScriptParserAgent
from agents.image_generator_agent import ImageGenerationAgent

async def main():
    """完整的剧本解析到图片生成流程"""

    # 剧本文本
    script_text = """
# 测试剧本

## 角色
- 小明: 程序员

## 场景1：咖啡馆
地点: 咖啡馆
时间: 清晨
描述: 阳光洒满咖啡馆

## 场景2：办公室
地点: 办公室
时间: 下午
描述: 忙碌的工作场景
    """

    # 步骤1：解析剧本
    parser = ScriptParserAgent()
    script = await parser.execute(script_text)

    print(f"解析完成: {script.title}, {len(script.scenes)}个场景")

    # 步骤2：生成图片
    generator = ImageGenerationAgent(config={
        'max_concurrent': 3,
        'image_width': 1024,
        'image_height': 576,
        'style': 'cinematic'
    })

    results = await generator.execute_concurrent(script.scenes)

    print(f"\n图片生成完成:")
    for result in results:
        print(f"  {result['scene_id']}: {result['image_path']}")

    # 清理资源
    await generator.close()

if __name__ == "__main__":
    asyncio.run(main())
```

---

## 小结

本部分实现了AI短剧生成系统的前两个核心模块：

1. **剧本解析模块**：
   - 定义了完整的数据模型（Scene、Character、Dialogue等）
   - 实现了文本剧本到结构化数据的转换
   - 支持灵活的剧本格式和自动优化

2. **图片生成模块**：
   - 封装了Nano Banana Pro API服务
   - 实现了批量图片生成Agent
   - 提供了并发控制和错误重试机制

下一部分将实现**视频生成**和**视频合成**功能，完成从图片到最终视频的转换。

---

**性能优化提示**：
- 并发数建议设置为3-5，避免触发API限流
- 图片生成建议使用1024x576分辨率（16:9），平衡质量和成本
- 可以先生成低分辨率预览，确认效果后再生成高质量版本

**下一步**：继续阅读**第3部分：核心代码实现（视频生成与合成）**。
