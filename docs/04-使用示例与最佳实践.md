# AIçŸ­å‰§è‡ªåŠ¨åŒ–ç”Ÿæˆç³»ç»Ÿå¼€å‘æ•™ç¨‹ï¼ˆç¬¬4éƒ¨åˆ†ï¼‰
## ä½¿ç”¨ç¤ºä¾‹ä¸æœ€ä½³å®è·µ

---

## ç›®å½•

1. [åŸºç¡€ä½¿ç”¨ç¤ºä¾‹](#1-åŸºç¡€ä½¿ç”¨ç¤ºä¾‹)
   - 1.1 [å¿«é€Ÿå¼€å§‹](#11-å¿«é€Ÿå¼€å§‹)
   - 1.2 [å®Œæ•´æµç¨‹ç¤ºä¾‹](#12-å®Œæ•´æµç¨‹ç¤ºä¾‹)
   - 1.3 [é…ç½®å‚æ•°è¯´æ˜](#13-é…ç½®å‚æ•°è¯´æ˜)
2. [é«˜çº§åŠŸèƒ½ç¤ºä¾‹](#2-é«˜çº§åŠŸèƒ½ç¤ºä¾‹)
   - 2.1 [æ‰¹é‡ç”Ÿæˆå¤šä¸ªçŸ­å‰§](#21-æ‰¹é‡ç”Ÿæˆå¤šä¸ªçŸ­å‰§)
   - 2.2 [è‡ªå®šä¹‰åˆ†é•œæ¨¡æ¿](#22-è‡ªå®šä¹‰åˆ†é•œæ¨¡æ¿)
   - 2.3 [é›†æˆè¯­éŸ³åˆæˆï¼ˆTTSï¼‰](#23-é›†æˆè¯­éŸ³åˆæˆtts)
   - 2.4 [æ–­ç‚¹ç»­ä¼ ](#24-æ–­ç‚¹ç»­ä¼ )
3. [æ€§èƒ½ä¼˜åŒ–](#3-æ€§èƒ½ä¼˜åŒ–)
   - 3.1 [å¹¶å‘å¤„ç†ç­–ç•¥](#31-å¹¶å‘å¤„ç†ç­–ç•¥)
   - 3.2 [APIè°ƒç”¨é€Ÿç‡æ§åˆ¶](#32-apiè°ƒç”¨é€Ÿç‡æ§åˆ¶)
   - 3.3 [ç¼“å­˜æœºåˆ¶](#33-ç¼“å­˜æœºåˆ¶)
   - 3.4 [èµ„æºç®¡ç†](#34-èµ„æºç®¡ç†)
4. [æˆæœ¬æ§åˆ¶](#4-æˆæœ¬æ§åˆ¶)
   - 4.1 [APIè°ƒç”¨ä¼˜åŒ–](#41-apiè°ƒç”¨ä¼˜åŒ–)
   - 4.2 [è´¨é‡ä¸æˆæœ¬å¹³è¡¡](#42-è´¨é‡ä¸æˆæœ¬å¹³è¡¡)
   - 4.3 [æˆæœ¬ä¼°ç®—å·¥å…·](#43-æˆæœ¬ä¼°ç®—å·¥å…·)
5. [é”™è¯¯å¤„ç†æœ€ä½³å®è·µ](#5-é”™è¯¯å¤„ç†æœ€ä½³å®è·µ)
   - 5.1 [ç½‘ç»œå¼‚å¸¸å¤„ç†](#51-ç½‘ç»œå¼‚å¸¸å¤„ç†)
   - 5.2 [APIé™æµåº”å¯¹](#52-apié™æµåº”å¯¹)
   - 5.3 [æ—¥å¿—è®°å½•è§„èŒƒ](#53-æ—¥å¿—è®°å½•è§„èŒƒ)

---

## 1. åŸºç¡€ä½¿ç”¨ç¤ºä¾‹

### 1.1 å¿«é€Ÿå¼€å§‹

åˆ›å»º`examples/quick_start.py`ï¼š

```python
import asyncio
from agents.orchestrator_agent import DramaGenerationOrchestrator

async def main():
    """æœ€ç®€å•çš„ä½¿ç”¨ç¤ºä¾‹"""

    # å‰§æœ¬æ–‡æœ¬
    script = """
# ç¨‹åºå‘˜çš„ä¸€å¤©

## è§’è‰²
- å°æ˜: 25å²çš„Pythonå¼€å‘è€…

## åœºæ™¯1ï¼šæ¸…æ™¨çš„å’–å•¡é¦†
åœ°ç‚¹: å’–å•¡é¦†
æ—¶é—´: æ¸…æ™¨
æè¿°: é˜³å…‰æ´’æ»¡å’–å•¡é¦†
æ—¶é•¿: 3.0

å°æ˜ï¼ˆå¾®ç¬‘ï¼‰ï¼šæ–°çš„ä¸€å¤©å¼€å§‹äº†ï¼

## åœºæ™¯2ï¼šåŠå…¬å®¤
åœ°ç‚¹: åŠå…¬å®¤
æ—¶é—´: ä¸Šåˆ
æè¿°: å°æ˜åœ¨ç”µè„‘å‰å·¥ä½œ
æ—¶é•¿: 3.5

å°æ˜ï¼ˆä¸“æ³¨ï¼‰ï¼šä»£ç ç»ˆäºè·‘é€šäº†ï¼
    """

    # åˆ›å»ºä¸»æ§Agent
    orchestrator = DramaGenerationOrchestrator(config={
        'image': {
            'max_concurrent': 3,
            'image_width': 1024,
            'image_height': 576
        },
        'video': {
            'max_concurrent': 2,
            'fps': 30,
            'resolution': '1920x1080'
        }
    })

    # ç”ŸæˆçŸ­å‰§
    try:
        video_path = await orchestrator.execute(
            script_text=script,
            output_filename="my_first_drama.mp4"
        )

        print(f"âœ… çŸ­å‰§ç”ŸæˆæˆåŠŸï¼")
        print(f"ğŸ“¹ è§†é¢‘è·¯å¾„: {video_path}")

    except Exception as e:
        print(f"âŒ ç”Ÿæˆå¤±è´¥: {e}")

    finally:
        await orchestrator.close()

if __name__ == "__main__":
    asyncio.run(main())
```

è¿è¡Œï¼š
```bash
python examples/quick_start.py
```

---

### 1.2 å®Œæ•´æµç¨‹ç¤ºä¾‹

åˆ›å»º`examples/complete_workflow.py`ï¼š

```python
import asyncio
from pathlib import Path
from agents.orchestrator_agent import DramaGenerationOrchestrator
from utils.logger import setup_logger
from datetime import datetime

async def progress_callback(percent: float, message: str):
    """è¿›åº¦å›è°ƒå‡½æ•°"""
    bar_length = 50
    filled = int(bar_length * percent / 100)
    bar = 'â–ˆ' * filled + '-' * (bar_length - filled)
    print(f'\r[{bar}] {percent:.1f}% - {message}', end='', flush=True)

async def main():
    """å®Œæ•´çš„çŸ­å‰§ç”Ÿæˆæµç¨‹ç¤ºä¾‹"""

    # è®¾ç½®æ—¥å¿—
    logger = setup_logger('drama_generation', level='INFO')

    # è¯»å–å‰§æœ¬æ–‡ä»¶
    script_file = Path("examples/sample_scripts/demo_script.txt")

    if not script_file.exists():
        logger.error(f"Script file not found: {script_file}")
        return

    with open(script_file, 'r', encoding='utf-8') as f:
        script_text = f.read()

    # é…ç½®å‚æ•°
    config = {
        'image': {
            'max_concurrent': 3,
            'image_width': 1024,
            'image_height': 576,
            'style': 'cinematic',
            'quality': 'high'
        },
        'video': {
            'max_concurrent': 2,
            'fps': 30,
            'resolution': '1920x1080',
            'motion_strength': 0.5
        },
        'composer': {
            'add_transitions': True,
            'transition_type': 'crossfade',
            'transition_duration': 0.5,
            'fps': 30,
            'preset': 'medium',
            'threads': 4,
            'bgm_volume': 0.3
        },
        'bgm_path': 'assets/bgm/peaceful.mp3',  # å¯é€‰
        'add_subtitles': False
    }

    # ç”Ÿæˆè¾“å‡ºæ–‡ä»¶å
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    output_filename = f"drama_{timestamp}.mp4"

    # åˆ›å»ºorchestrator
    orchestrator = DramaGenerationOrchestrator(config=config)

    logger.info("=" * 60)
    logger.info("Starting AI Drama Generation")
    logger.info("=" * 60)

    try:
        # æ‰§è¡Œç”Ÿæˆï¼ˆå¸¦è¿›åº¦å›è°ƒï¼‰
        video_path = await orchestrator.execute(
            script_text=script_text,
            output_filename=output_filename,
            progress_callback=progress_callback
        )

        print()  # æ¢è¡Œ
        logger.info("=" * 60)
        logger.info("âœ… Generation Completed Successfully!")
        logger.info(f"ğŸ“¹ Video saved to: {video_path}")
        logger.info("=" * 60)

        # è·å–è§†é¢‘ä¿¡æ¯
        from utils.video_utils import FFmpegProcessor
        ffmpeg = FFmpegProcessor()
        video_info = ffmpeg.get_video_info(video_path)

        logger.info("\nğŸ“Š Video Information:")
        logger.info(f"  Duration: {video_info['duration']:.2f}s")
        logger.info(f"  Resolution: {video_info['width']}x{video_info['height']}")
        logger.info(f"  FPS: {video_info['fps']}")
        logger.info(f"  Codec: {video_info['codec']}")

    except Exception as e:
        logger.error(f"âŒ Generation failed: {e}", exc_info=True)

    finally:
        await orchestrator.close()
        logger.info("Resources cleaned up")

if __name__ == "__main__":
    asyncio.run(main())
```

---

### 1.3 é…ç½®å‚æ•°è¯´æ˜

åˆ›å»º`config/default_config.yaml`ï¼š

```yaml
# AIçŸ­å‰§ç”Ÿæˆç³»ç»Ÿé»˜è®¤é…ç½®

# å›¾ç‰‡ç”Ÿæˆé…ç½®
image:
  max_concurrent: 3          # æœ€å¤§å¹¶å‘æ•°
  image_width: 1024          # å›¾ç‰‡å®½åº¦
  image_height: 576          # å›¾ç‰‡é«˜åº¦ï¼ˆ16:9ï¼‰
  style: cinematic           # è§†è§‰é£æ ¼
  quality: high              # è´¨é‡ï¼ˆhigh/medium/lowï¼‰

# è§†é¢‘ç”Ÿæˆé…ç½®
video:
  max_concurrent: 2          # æœ€å¤§å¹¶å‘æ•°ï¼ˆå»ºè®®è¾ƒä½ï¼‰
  fps: 30                    # å¸§ç‡
  resolution: "1920x1080"    # åˆ†è¾¨ç‡
  motion_strength: 0.5       # è¿åŠ¨å¼ºåº¦ï¼ˆ0.0-1.0ï¼‰

# è§†é¢‘åˆæˆé…ç½®
composer:
  add_transitions: true      # æ˜¯å¦æ·»åŠ è½¬åœº
  transition_type: crossfade # è½¬åœºç±»å‹ï¼ˆfade/crossfadeï¼‰
  transition_duration: 0.5   # è½¬åœºæ—¶é•¿ï¼ˆç§’ï¼‰
  fps: 30                    # è¾“å‡ºå¸§ç‡
  preset: medium             # ç¼–ç é¢„è®¾ï¼ˆultrafast/fast/medium/slowï¼‰
  threads: 4                 # ç¼–ç çº¿ç¨‹æ•°
  bgm_volume: 0.3           # èƒŒæ™¯éŸ³ä¹éŸ³é‡

# å¯é€‰åŠŸèƒ½
bgm_path: null               # èƒŒæ™¯éŸ³ä¹è·¯å¾„
add_subtitles: false         # æ˜¯å¦æ·»åŠ å­—å¹•

# è¾“å‡ºç›®å½•
output_dir: ./output
temp_dir: ./temp

# æ—¥å¿—é…ç½®
log_level: INFO
log_file: ./logs/drama_generation.log
```

åŠ è½½é…ç½®ï¼š

```python
import yaml
from pathlib import Path

def load_config(config_path: str = "config/default_config.yaml") -> dict:
    """åŠ è½½YAMLé…ç½®æ–‡ä»¶"""
    with open(config_path, 'r', encoding='utf-8') as f:
        return yaml.safe_load(f)

# ä½¿ç”¨
config = load_config()
orchestrator = DramaGenerationOrchestrator(config=config)
```

---

## 2. é«˜çº§åŠŸèƒ½ç¤ºä¾‹

### 2.1 æ‰¹é‡ç”Ÿæˆå¤šä¸ªçŸ­å‰§

åˆ›å»º`examples/batch_generation.py`ï¼š

```python
import asyncio
from pathlib import Path
from typing import List
from agents.orchestrator_agent import DramaGenerationOrchestrator
import logging

async def generate_single_drama(
    orchestrator: DramaGenerationOrchestrator,
    script_file: Path,
    output_dir: Path
) -> str:
    """ç”Ÿæˆå•ä¸ªçŸ­å‰§"""

    with open(script_file, 'r', encoding='utf-8') as f:
        script_text = f.read()

    output_filename = f"{script_file.stem}.mp4"

    video_path = await orchestrator.execute(
        script_text=script_text,
        output_filename=output_filename
    )

    return video_path

async def batch_generate_dramas(script_dir: Path, output_dir: Path):
    """æ‰¹é‡ç”ŸæˆçŸ­å‰§"""

    logger = logging.getLogger(__name__)

    # è·å–æ‰€æœ‰å‰§æœ¬æ–‡ä»¶
    script_files = list(script_dir.glob("*.txt"))

    if not script_files:
        logger.error(f"No script files found in {script_dir}")
        return

    logger.info(f"Found {len(script_files)} script files")

    # åˆ›å»ºorchestrator
    config = {
        'image': {'max_concurrent': 3},
        'video': {'max_concurrent': 2}
    }
    orchestrator = DramaGenerationOrchestrator(config=config)

    try:
        # é¡ºåºç”Ÿæˆï¼ˆé¿å…èµ„æºè€—å°½ï¼‰
        results = []

        for i, script_file in enumerate(script_files, 1):
            logger.info(f"\n{'='*60}")
            logger.info(f"Processing {i}/{len(script_files)}: {script_file.name}")
            logger.info(f"{'='*60}")

            try:
                video_path = await generate_single_drama(
                    orchestrator,
                    script_file,
                    output_dir
                )

                results.append({
                    'script': script_file.name,
                    'video': video_path,
                    'status': 'success'
                })

                logger.info(f"âœ… Completed: {video_path}")

            except Exception as e:
                logger.error(f"âŒ Failed: {script_file.name} - {e}")

                results.append({
                    'script': script_file.name,
                    'error': str(e),
                    'status': 'failed'
                })

        # æ‰“å°æ€»ç»“
        logger.info(f"\n{'='*60}")
        logger.info("Batch Generation Summary")
        logger.info(f"{'='*60}")

        success_count = sum(1 for r in results if r['status'] == 'success')
        logger.info(f"Total: {len(results)}")
        logger.info(f"Success: {success_count}")
        logger.info(f"Failed: {len(results) - success_count}")

    finally:
        await orchestrator.close()

async def main():
    script_dir = Path("examples/sample_scripts")
    output_dir = Path("output/batch")
    output_dir.mkdir(parents=True, exist_ok=True)

    await batch_generate_dramas(script_dir, output_dir)

if __name__ == "__main__":
    asyncio.run(main())
```

---

### 2.2 è‡ªå®šä¹‰åˆ†é•œæ¨¡æ¿

åˆ›å»º`examples/custom_storyboard_template.py`ï¼š

```python
from typing import List, Dict, Any
from models.script_models import Scene, ShotType, CameraMovement

class StoryboardTemplate:
    """åˆ†é•œæ¨¡æ¿"""

    @staticmethod
    def apply_template(scenes: List[Scene], template_name: str) -> List[Scene]:
        """
        åº”ç”¨åˆ†é•œæ¨¡æ¿

        Args:
            scenes: åŸå§‹åœºæ™¯åˆ—è¡¨
            template_name: æ¨¡æ¿åç§°

        Returns:
            åº”ç”¨æ¨¡æ¿åçš„åœºæ™¯åˆ—è¡¨
        """
        templates = {
            'dialogue_heavy': StoryboardTemplate.dialogue_heavy_template,
            'action_packed': StoryboardTemplate.action_packed_template,
            'cinematic': StoryboardTemplate.cinematic_template
        }

        template_func = templates.get(template_name)
        if not template_func:
            raise ValueError(f"Unknown template: {template_name}")

        return template_func(scenes)

    @staticmethod
    def dialogue_heavy_template(scenes: List[Scene]) -> List[Scene]:
        """
        å¯¹è¯å¯†é›†å‹æ¨¡æ¿
        - å¤šä½¿ç”¨ç‰¹å†™å’Œä¸­æ™¯
        - é™æ€é•œå¤´ä¸ºä¸»
        """
        for scene in scenes:
            if scene.dialogues:
                scene.shot_type = ShotType.CLOSE_UP
                scene.camera_movement = CameraMovement.STATIC
            else:
                scene.shot_type = ShotType.MEDIUM_SHOT

        return scenes

    @staticmethod
    def action_packed_template(scenes: List[Scene]) -> List[Scene]:
        """
        åŠ¨ä½œå¯†é›†å‹æ¨¡æ¿
        - ä½¿ç”¨å…¨æ™¯å’Œè¿œæ™¯
        - æ›´å¤šè¿é•œ
        """
        for i, scene in enumerate(scenes):
            # äº¤æ›¿ä½¿ç”¨ä¸åŒé•œå¤´
            if i % 2 == 0:
                scene.shot_type = ShotType.LONG_SHOT
                scene.camera_movement = CameraMovement.TRACKING
            else:
                scene.shot_type = ShotType.FULL_SHOT
                scene.camera_movement = CameraMovement.PAN

        return scenes

    @staticmethod
    def cinematic_template(scenes: List[Scene]) -> List[Scene]:
        """
        ç”µå½±æ„Ÿæ¨¡æ¿
        - å¼€åœºç”¨å…¨æ™¯
        - é«˜æ½®ç”¨ç‰¹å†™
        - ç»“å°¾ç”¨è¿œæ™¯
        """
        if not scenes:
            return scenes

        # å¼€åœº
        scenes[0].shot_type = ShotType.LONG_SHOT
        scenes[0].camera_movement = CameraMovement.DOLLY

        # ä¸­é—´éƒ¨åˆ†
        for scene in scenes[1:-1]:
            if scene.dialogues:
                scene.shot_type = ShotType.CLOSE_UP
            else:
                scene.shot_type = ShotType.MEDIUM_SHOT

        # ç»“å°¾
        if len(scenes) > 1:
            scenes[-1].shot_type = ShotType.LONG_SHOT
            scenes[-1].camera_movement = CameraMovement.ZOOM

        return scenes

# ä½¿ç”¨ç¤ºä¾‹
async def main():
    from agents.script_parser_agent import ScriptParserAgent

    script_text = """..."""  # å‰§æœ¬å†…å®¹

    # è§£æå‰§æœ¬
    parser = ScriptParserAgent()
    script = await parser.execute(script_text)

    # åº”ç”¨æ¨¡æ¿
    script.scenes = StoryboardTemplate.apply_template(
        script.scenes,
        template_name='cinematic'
    )

    # ç»§ç»­ç”Ÿæˆæµç¨‹...
```

---

### 2.3 é›†æˆè¯­éŸ³åˆæˆï¼ˆTTSï¼‰

åˆ›å»º`services/tts_service.py`ï¼š

```python
import asyncio
from pathlib import Path
from typing import Optional
import httpx
import logging

class TTSService:
    """è¯­éŸ³åˆæˆæœåŠ¡ï¼ˆç¤ºä¾‹ï¼šä½¿ç”¨OpenAI TTS APIï¼‰"""

    def __init__(self, api_key: str):
        self.api_key = api_key
        self.base_url = "https://api.openai.com/v1"
        self.logger = logging.getLogger(__name__)

    async def text_to_speech(
        self,
        text: str,
        voice: str = "alloy",
        output_path: Path = None
    ) -> Path:
        """
        å°†æ–‡æœ¬è½¬æ¢ä¸ºè¯­éŸ³

        Args:
            text: æ–‡æœ¬å†…å®¹
            voice: è¯­éŸ³ç±»å‹
            output_path: è¾“å‡ºè·¯å¾„

        Returns:
            éŸ³é¢‘æ–‡ä»¶è·¯å¾„
        """
        if not output_path:
            output_path = Path(f"temp/speech_{hash(text)}.mp3")

        output_path.parent.mkdir(parents=True, exist_ok=True)

        async with httpx.AsyncClient() as client:
            response = await client.post(
                f"{self.base_url}/audio/speech",
                headers={
                    "Authorization": f"Bearer {self.api_key}",
                    "Content-Type": "application/json"
                },
                json={
                    "model": "tts-1",
                    "input": text,
                    "voice": voice
                },
                timeout=60.0
            )

            response.raise_for_status()

            with open(output_path, 'wb') as f:
                f.write(response.content)

        self.logger.info(f"TTS generated: {output_path}")
        return output_path

# é›†æˆåˆ°VideoComposerAgent
class EnhancedVideoComposerAgent(VideoComposerAgent):
    """å¢å¼ºç‰ˆè§†é¢‘åˆæˆAgentï¼Œæ”¯æŒTTS"""

    def __init__(self, *args, tts_service: Optional[TTSService] = None, **kwargs):
        super().__init__(*args, **kwargs)
        self.tts_service = tts_service

    async def add_voice_over(
        self,
        video_clip,
        scenes: List[Scene]
    ):
        """ä¸ºè§†é¢‘æ·»åŠ é…éŸ³"""

        if not self.tts_service:
            return video_clip

        audio_clips = []
        current_time = 0

        for scene in scenes:
            for dialogue in scene.dialogues:
                # ç”Ÿæˆè¯­éŸ³
                audio_path = await self.tts_service.text_to_speech(
                    dialogue.content,
                    voice=dialogue.voice_style or "alloy"
                )

                # åŠ è½½éŸ³é¢‘
                audio_clip = AudioFileClip(str(audio_path))
                audio_clip = audio_clip.set_start(current_time)

                audio_clips.append(audio_clip)
                current_time += audio_clip.duration

        if audio_clips:
            from moviepy.audio.AudioClip import CompositeAudioClip
            final_audio = CompositeAudioClip(audio_clips)
            video_clip = video_clip.set_audio(final_audio)

        return video_clip
```

---

### 2.4 æ–­ç‚¹ç»­ä¼ 

åˆ›å»º`examples/resume_generation.py`ï¼š

```python
import asyncio
from pathlib import Path
from agents.orchestrator_agent import DramaGenerationOrchestrator
from utils.checkpoint import CheckpointManager

class ResumableOrchestrator(DramaGenerationOrchestrator):
    """æ”¯æŒæ–­ç‚¹ç»­ä¼ çš„Orchestrator"""

    def __init__(self, *args, task_id: str = None, **kwargs):
        super().__init__(*args, **kwargs)
        self.task_id = task_id or f"task_{id(self)}"
        self.checkpoint_manager = CheckpointManager()

    async def execute_with_resume(
        self,
        script_text: str,
        output_filename: str = "drama.mp4",
        resume: bool = True
    ) -> str:
        """æ”¯æŒæ–­ç‚¹ç»­ä¼ çš„æ‰§è¡Œ"""

        # å°è¯•åŠ è½½æ£€æŸ¥ç‚¹
        checkpoint = None
        if resume:
            checkpoint = self.checkpoint_manager.load_checkpoint(self.task_id)

        if checkpoint:
            self.logger.info(f"Resuming from stage: {checkpoint['stage']}")
            return await self._resume_from_checkpoint(
                checkpoint,
                script_text,
                output_filename
            )
        else:
            return await self._execute_fresh(script_text, output_filename)

    async def _execute_fresh(self, script_text: str, output_filename: str) -> str:
        """ä»å¤´å¼€å§‹æ‰§è¡Œ"""

        try:
            # æ­¥éª¤1ï¼šè§£æå‰§æœ¬
            script = await self.script_parser.execute(script_text)
            self.checkpoint_manager.save_checkpoint(
                self.task_id,
                'script_parsed',
                {'script': script.dict()}
            )

            # æ­¥éª¤2ï¼šç”Ÿæˆå›¾ç‰‡
            image_results = await self.image_generator.execute_concurrent(script.scenes)
            self.checkpoint_manager.save_checkpoint(
                self.task_id,
                'images_generated',
                {'image_results': image_results}
            )

            # æ­¥éª¤3ï¼šç”Ÿæˆè§†é¢‘
            video_results = await self.video_generator.execute(
                image_results,
                script.scenes
            )
            self.checkpoint_manager.save_checkpoint(
                self.task_id,
                'videos_generated',
                {'video_results': video_results}
            )

            # æ­¥éª¤4ï¼šåˆæˆè§†é¢‘
            final_video = await self.video_composer.execute(
                video_results,
                output_filename=output_filename
            )

            # æ¸…é™¤æ£€æŸ¥ç‚¹
            self.checkpoint_manager.clear_checkpoints(self.task_id)

            return final_video

        except Exception as e:
            self.logger.error(f"Generation failed at some stage, checkpoint saved")
            raise

    async def _resume_from_checkpoint(
        self,
        checkpoint: dict,
        script_text: str,
        output_filename: str
    ) -> str:
        """ä»æ£€æŸ¥ç‚¹æ¢å¤"""

        stage = checkpoint['stage']
        data = checkpoint['data']

        if stage == 'script_parsed':
            # ä»å›¾ç‰‡ç”Ÿæˆå¼€å§‹
            from models.script_models import Script
            script = Script(**data['script'])

            image_results = await self.image_generator.execute_concurrent(script.scenes)
            # ... ç»§ç»­åç»­æ­¥éª¤

        elif stage == 'images_generated':
            # ä»è§†é¢‘ç”Ÿæˆå¼€å§‹
            # ...

        elif stage == 'videos_generated':
            # ç›´æ¥åˆæˆ
            final_video = await self.video_composer.execute(
                data['video_results'],
                output_filename=output_filename
            )
            return final_video

        # å®Œæ•´å®ç°çœç•¥...

async def main():
    """æ–­ç‚¹ç»­ä¼ ç¤ºä¾‹"""

    orchestrator = ResumableOrchestrator(
        task_id="my_drama_task",
        config={...}
    )

    try:
        video_path = await orchestrator.execute_with_resume(
            script_text="...",
            output_filename="drama.mp4",
            resume=True  # å¦‚æœä¹‹å‰å¤±è´¥äº†ï¼Œä¼šè‡ªåŠ¨ç»­ä¼ 
        )

        print(f"Video generated: {video_path}")

    finally:
        await orchestrator.close()

if __name__ == "__main__":
    asyncio.run(main())
```

---

## 3. æ€§èƒ½ä¼˜åŒ–

### 3.1 å¹¶å‘å¤„ç†ç­–ç•¥

```python
from utils.concurrency import ConcurrencyLimiter
import asyncio

class OptimizedImageGenerator(ImageGenerationAgent):
    """ä¼˜åŒ–çš„å›¾ç‰‡ç”Ÿæˆå™¨"""

    async def execute_with_batching(
        self,
        scenes: List[Scene],
        batch_size: int = 5
    ) -> List[Dict[str, Any]]:
        """
        åˆ†æ‰¹å¹¶å‘ç”Ÿæˆï¼Œé¿å…ä¸€æ¬¡æ€§å¯åŠ¨è¿‡å¤šä»»åŠ¡

        Args:
            scenes: åœºæ™¯åˆ—è¡¨
            batch_size: æ‰¹æ¬¡å¤§å°

        Returns:
            ç”Ÿæˆç»“æœ
        """
        all_results = []

        for i in range(0, len(scenes), batch_size):
            batch = scenes[i:i + batch_size]
            self.logger.info(f"Processing batch {i//batch_size + 1}")

            # å¹¶å‘å¤„ç†å½“å‰æ‰¹æ¬¡
            results = await self.limiter.run_batch(
                self._generate_scene_image,
                batch
            )

            all_results.extend(results)

            # æ‰¹æ¬¡é—´ç¨å¾®å»¶è¿Ÿï¼Œé¿å…APIé™æµ
            if i + batch_size < len(scenes):
                await asyncio.sleep(1.0)

        return all_results
```

---

### 3.2 APIè°ƒç”¨é€Ÿç‡æ§åˆ¶

åˆ›å»º`utils/rate_limiter.py`ï¼š

```python
import asyncio
import time
from collections import deque

class RateLimiter:
    """APIè°ƒç”¨é€Ÿç‡é™åˆ¶å™¨"""

    def __init__(self, max_calls: int, time_window: float):
        """
        åˆå§‹åŒ–é€Ÿç‡é™åˆ¶å™¨

        Args:
            max_calls: æ—¶é—´çª—å£å†…æœ€å¤§è°ƒç”¨æ¬¡æ•°
            time_window: æ—¶é—´çª—å£ï¼ˆç§’ï¼‰
        """
        self.max_calls = max_calls
        self.time_window = time_window
        self.calls = deque()

    async def acquire(self):
        """è·å–è°ƒç”¨è®¸å¯"""

        now = time.time()

        # ç§»é™¤è¿‡æœŸçš„è°ƒç”¨è®°å½•
        while self.calls and self.calls[0] < now - self.time_window:
            self.calls.popleft()

        # å¦‚æœè¾¾åˆ°é™åˆ¶ï¼Œç­‰å¾…
        if len(self.calls) >= self.max_calls:
            sleep_time = self.calls[0] + self.time_window - now
            if sleep_time > 0:
                await asyncio.sleep(sleep_time)
                return await self.acquire()

        # è®°å½•æœ¬æ¬¡è°ƒç”¨
        self.calls.append(now)

# ä½¿ç”¨ç¤ºä¾‹
class RateLimitedService(NanoBananaService):
    """å¸¦é€Ÿç‡é™åˆ¶çš„æœåŠ¡"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        # é™åˆ¶ï¼šæ¯åˆ†é’Ÿæœ€å¤š30æ¬¡è°ƒç”¨
        self.rate_limiter = RateLimiter(max_calls=30, time_window=60.0)

    async def generate_image(self, *args, **kwargs):
        # è·å–è°ƒç”¨è®¸å¯
        await self.rate_limiter.acquire()

        # è°ƒç”¨åŸæ–¹æ³•
        return await super().generate_image(*args, **kwargs)
```

---

### 3.3 ç¼“å­˜æœºåˆ¶

åˆ›å»º`utils/cache.py`ï¼š

```python
import hashlib
import json
from pathlib import Path
from typing import Any, Optional
import pickle

class ResultCache:
    """ç»“æœç¼“å­˜å™¨"""

    def __init__(self, cache_dir: Path = Path("./cache")):
        self.cache_dir = cache_dir
        self.cache_dir.mkdir(parents=True, exist_ok=True)

    def _get_cache_key(self, data: Any) -> str:
        """ç”Ÿæˆç¼“å­˜é”®"""
        json_str = json.dumps(data, sort_keys=True)
        return hashlib.md5(json_str.encode()).hexdigest()

    def get(self, key_data: Any) -> Optional[Any]:
        """è·å–ç¼“å­˜"""
        cache_key = self._get_cache_key(key_data)
        cache_file = self.cache_dir / f"{cache_key}.pkl"

        if not cache_file.exists():
            return None

        try:
            with open(cache_file, 'rb') as f:
                return pickle.load(f)
        except Exception:
            return None

    def set(self, key_data: Any, value: Any):
        """è®¾ç½®ç¼“å­˜"""
        cache_key = self._get_cache_key(key_data)
        cache_file = self.cache_dir / f"{cache_key}.pkl"

        with open(cache_file, 'wb') as f:
            pickle.dump(value, f)

# é›†æˆåˆ°Agent
class CachedImageGenerator(ImageGenerationAgent):
    """å¸¦ç¼“å­˜çš„å›¾ç‰‡ç”Ÿæˆå™¨"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.cache = ResultCache(cache_dir=Path("./cache/images"))

    async def _generate_scene_image(self, scene: Scene) -> Dict[str, Any]:
        # æ£€æŸ¥ç¼“å­˜
        cache_key = {
            'prompt': scene.to_image_prompt(),
            'config': self.config
        }

        cached_result = self.cache.get(cache_key)
        if cached_result:
            self.logger.info(f"Using cached image for {scene.scene_id}")
            return cached_result

        # ç”Ÿæˆæ–°å›¾ç‰‡
        result = await super()._generate_scene_image(scene)

        # ä¿å­˜åˆ°ç¼“å­˜
        self.cache.set(cache_key, result)

        return result
```

---

### 3.4 èµ„æºç®¡ç†

```python
import psutil
import asyncio
from typing import Optional

class ResourceMonitor:
    """èµ„æºç›‘æ§å™¨"""

    def __init__(
        self,
        max_memory_percent: float = 80.0,
        max_cpu_percent: float = 90.0
    ):
        self.max_memory_percent = max_memory_percent
        self.max_cpu_percent = max_cpu_percent

    async def wait_for_resources(self, check_interval: float = 1.0):
        """ç­‰å¾…èµ„æºå¯ç”¨"""

        while True:
            memory = psutil.virtual_memory().percent
            cpu = psutil.cpu_percent(interval=0.1)

            if memory < self.max_memory_percent and cpu < self.max_cpu_percent:
                break

            print(f"â³ Waiting for resources... (Memory: {memory:.1f}%, CPU: {cpu:.1f}%)")
            await asyncio.sleep(check_interval)

# ä½¿ç”¨
resource_monitor = ResourceMonitor()

async def generate_with_resource_management():
    # ç­‰å¾…èµ„æºå……è¶³
    await resource_monitor.wait_for_resources()

    # æ‰§è¡Œç”Ÿæˆä»»åŠ¡
    result = await orchestrator.execute(...)
```

---

## 4. æˆæœ¬æ§åˆ¶

### 4.1 APIè°ƒç”¨ä¼˜åŒ–

```python
class CostOptimizedOrchestrator(DramaGenerationOrchestrator):
    """æˆæœ¬ä¼˜åŒ–çš„Orchestrator"""

    async def execute_with_preview(
        self,
        script_text: str,
        preview_mode: bool = True
    ) -> str:
        """
        é¢„è§ˆæ¨¡å¼ï¼šå…ˆç”Ÿæˆä½è´¨é‡ç‰ˆæœ¬ç¡®è®¤æ•ˆæœ

        Args:
            script_text: å‰§æœ¬
            preview_mode: æ˜¯å¦ä½¿ç”¨é¢„è§ˆæ¨¡å¼

        Returns:
            è§†é¢‘è·¯å¾„
        """

        if preview_mode:
            # ä½¿ç”¨ä½è´¨é‡å‚æ•°
            self.config['image']['image_width'] = 512
            self.config['image']['image_height'] = 288
            self.config['image']['quality'] = 'low'
            self.config['video']['resolution'] = '1280x720'

        result = await self.execute(script_text)

        if preview_mode:
            print("\nğŸ¬ é¢„è§ˆç‰ˆæœ¬ç”Ÿæˆå®Œæˆï¼")
            print("ç¡®è®¤æ•ˆæœåï¼Œå¯ä»¥ä½¿ç”¨é«˜è´¨é‡æ¨¡å¼é‡æ–°ç”Ÿæˆã€‚")

        return result
```

---

### 4.2 è´¨é‡ä¸æˆæœ¬å¹³è¡¡

```python
# é…ç½®é¢„è®¾
QUALITY_PRESETS = {
    'low': {
        'image': {'width': 512, 'height': 288, 'quality': 'low'},
        'video': {'resolution': '1280x720', 'fps': 24},
        'cost_multiplier': 0.3
    },
    'medium': {
        'image': {'width': 1024, 'height': 576, 'quality': 'medium'},
        'video': {'resolution': '1920x1080', 'fps': 30},
        'cost_multiplier': 1.0
    },
    'high': {
        'image': {'width': 2048, 'height': 1152, 'quality': 'high'},
        'video': {'resolution': '3840x2160', 'fps': 60},
        'cost_multiplier': 3.5
    }
}

def apply_quality_preset(config: dict, preset: str) -> dict:
    """åº”ç”¨è´¨é‡é¢„è®¾"""
    if preset in QUALITY_PRESETS:
        preset_config = QUALITY_PRESETS[preset]
        config['image'].update(preset_config['image'])
        config['video'].update(preset_config['video'])
    return config
```

---

### 4.3 æˆæœ¬ä¼°ç®—å·¥å…·

åˆ›å»º`utils/cost_estimator.py`ï¼š

```python
from models.script_models import Script

class CostEstimator:
    """æˆæœ¬ä¼°ç®—å™¨"""

    # å‡è®¾çš„å®šä»·ï¼ˆå®é™…è¯·å‚è€ƒAPIå®˜æ–¹å®šä»·ï¼‰
    PRICING = {
        'nano_banana': {
            'low': 0.01,      # æ¯å¼ å›¾ç‰‡
            'medium': 0.02,
            'high': 0.05
        },
        'veo3': {
            'per_second': 0.10  # æ¯ç§’è§†é¢‘
        }
    }

    @classmethod
    def estimate_cost(
        cls,
        script: Script,
        quality: str = 'medium'
    ) -> dict:
        """
        ä¼°ç®—ç”Ÿæˆæˆæœ¬

        Returns:
            æˆæœ¬æ˜ç»†å­—å…¸
        """

        num_scenes = script.total_scenes
        total_duration = script.total_duration

        # å›¾ç‰‡ç”Ÿæˆæˆæœ¬
        image_cost = num_scenes * cls.PRICING['nano_banana'][quality]

        # è§†é¢‘ç”Ÿæˆæˆæœ¬
        video_cost = total_duration * cls.PRICING['veo3']['per_second']

        total_cost = image_cost + video_cost

        return {
            'image_cost': image_cost,
            'video_cost': video_cost,
            'total_cost': total_cost,
            'num_scenes': num_scenes,
            'total_duration': total_duration,
            'currency': 'USD'
        }

# ä½¿ç”¨
script = await parser.execute(script_text)
cost_estimate = CostEstimator.estimate_cost(script, quality='medium')

print(f"ğŸ“Š æˆæœ¬ä¼°ç®—:")
print(f"  å›¾ç‰‡ç”Ÿæˆ: ${cost_estimate['image_cost']:.2f}")
print(f"  è§†é¢‘ç”Ÿæˆ: ${cost_estimate['video_cost']:.2f}")
print(f"  æ€»è®¡: ${cost_estimate['total_cost']:.2f}")

# è¯¢é—®ç”¨æˆ·æ˜¯å¦ç»§ç»­
proceed = input("æ˜¯å¦ç»§ç»­ç”Ÿæˆï¼Ÿ(y/n): ")
```

---

## 5. é”™è¯¯å¤„ç†æœ€ä½³å®è·µ

### 5.1 ç½‘ç»œå¼‚å¸¸å¤„ç†

```python
import httpx
from tenacity import (
    retry,
    stop_after_attempt,
    wait_exponential,
    retry_if_exception_type
)

class RobustAPIClient:
    """å¥å£®çš„APIå®¢æˆ·ç«¯"""

    @retry(
        stop=stop_after_attempt(5),
        wait=wait_exponential(multiplier=1, min=2, max=30),
        retry=retry_if_exception_type((httpx.NetworkError, httpx.TimeoutException))
    )
    async def call_api(self, *args, **kwargs):
        """å¸¦é‡è¯•çš„APIè°ƒç”¨"""
        try:
            return await self._do_api_call(*args, **kwargs)
        except httpx.HTTPStatusError as e:
            if e.response.status_code == 429:  # é™æµ
                # ä»å“åº”å¤´è¯»å–é‡è¯•æ—¶é—´
                retry_after = e.response.headers.get('Retry-After', 60)
                await asyncio.sleep(int(retry_after))
                raise  # é‡è¯•
            elif e.response.status_code >= 500:  # æœåŠ¡å™¨é”™è¯¯
                raise  # é‡è¯•
            else:
                # å®¢æˆ·ç«¯é”™è¯¯ï¼Œä¸é‡è¯•
                raise
```

---

### 5.2 APIé™æµåº”å¯¹

```python
class AdaptiveRateLimiter:
    """è‡ªé€‚åº”é€Ÿç‡é™åˆ¶å™¨"""

    def __init__(self, initial_rate: int = 10):
        self.current_rate = initial_rate
        self.min_rate = 1
        self.max_rate = 50

    async def handle_429(self):
        """å¤„ç†429é™æµå“åº”"""
        # é™ä½é€Ÿç‡
        self.current_rate = max(self.min_rate, self.current_rate // 2)
        print(f"âš ï¸ Rate limited, reducing to {self.current_rate} req/min")

    async def handle_success(self):
        """å¤„ç†æˆåŠŸå“åº”"""
        # é€æ¸å¢åŠ é€Ÿç‡
        self.current_rate = min(self.max_rate, self.current_rate + 1)
```

---

### 5.3 æ—¥å¿—è®°å½•è§„èŒƒ

åˆ›å»º`utils/logger.py`ï¼š

```python
import logging
from pathlib import Path
from logging.handlers import RotatingFileHandler
from datetime import datetime

def setup_logger(
    name: str = 'drama_generation',
    level: str = 'INFO',
    log_file: Path = None
) -> logging.Logger:
    """
    é…ç½®æ—¥å¿—è®°å½•å™¨

    Args:
        name: æ—¥å¿—å™¨åç§°
        level: æ—¥å¿—çº§åˆ«
        log_file: æ—¥å¿—æ–‡ä»¶è·¯å¾„

    Returns:
        é…ç½®å¥½çš„logger
    """

    logger = logging.getLogger(name)
    logger.setLevel(getattr(logging, level.upper()))

    # æ¸…é™¤ç°æœ‰handlers
    logger.handlers.clear()

    # æ ¼å¼åŒ–å™¨
    formatter = logging.Formatter(
        '[%(asctime)s] [%(name)s] [%(levelname)s] %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )

    # æ§åˆ¶å°handler
    console_handler = logging.StreamHandler()
    console_handler.setFormatter(formatter)
    logger.addHandler(console_handler)

    # æ–‡ä»¶handler
    if log_file:
        log_file = Path(log_file)
        log_file.parent.mkdir(parents=True, exist_ok=True)

        file_handler = RotatingFileHandler(
            log_file,
            maxBytes=10 * 1024 * 1024,  # 10MB
            backupCount=5,
            encoding='utf-8'
        )
        file_handler.setFormatter(formatter)
        logger.addHandler(file_handler)

    return logger

# ä½¿ç”¨
logger = setup_logger(
    name='my_drama_app',
    level='INFO',
    log_file=Path('logs/drama.log')
)

logger.info("Application started")
logger.error("An error occurred", exc_info=True)  # åŒ…å«å †æ ˆè·Ÿè¸ª
```

---

## æ€»ç»“

æœ¬éƒ¨åˆ†æä¾›äº†å®Œæ•´çš„ä½¿ç”¨ç¤ºä¾‹å’Œæœ€ä½³å®è·µï¼š

- **åŸºç¡€ä½¿ç”¨**ï¼šå¿«é€Ÿå¼€å§‹å’Œå®Œæ•´æµç¨‹ç¤ºä¾‹
- **é«˜çº§åŠŸèƒ½**ï¼šæ‰¹é‡ç”Ÿæˆã€è‡ªå®šä¹‰æ¨¡æ¿ã€TTSé›†æˆã€æ–­ç‚¹ç»­ä¼ 
- **æ€§èƒ½ä¼˜åŒ–**ï¼šå¹¶å‘ç­–ç•¥ã€é€Ÿç‡æ§åˆ¶ã€ç¼“å­˜ã€èµ„æºç®¡ç†
- **æˆæœ¬æ§åˆ¶**ï¼šè´¨é‡é¢„è®¾ã€æˆæœ¬ä¼°ç®—
- **é”™è¯¯å¤„ç†**ï¼šç½‘ç»œå¼‚å¸¸ã€é™æµåº”å¯¹ã€æ—¥å¿—è§„èŒƒ

ä¸‹ä¸€éƒ¨åˆ†å°†ä»‹ç»**å¸¸è§é—®é¢˜è§£å†³æ–¹æ¡ˆ**å’Œ**ç”Ÿäº§éƒ¨ç½²æŒ‡å—**ã€‚

---

**ä¸‹ä¸€æ­¥**ï¼šç»§ç»­é˜…è¯»**ç¬¬5éƒ¨åˆ†ï¼šå¸¸è§é—®é¢˜ä¸é¡¹ç›®éƒ¨ç½²**ã€‚
